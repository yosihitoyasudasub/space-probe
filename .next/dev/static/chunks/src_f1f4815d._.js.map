{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/my_projects/space-probe-game-next/space-probe-game-next/src/lib/physics.ts"],"sourcesContent":["// This physics module avoids direct dependence on three.js types so it can be\r\n// unit-tested and reused. Positions/velocities are plain number tuples [x,y,z].\r\n\r\nexport type Vec3 = [number, number, number];\r\n\r\nexport type Body = {\r\n    id: string;\r\n    mass: number;\r\n    position: Vec3;\r\n    velocity: Vec3;\r\n    radius?: number; // visual / encounter radius\r\n    isProbe?: boolean;\r\n    isStatic?: boolean; // if true, body should not be moved by simulation (e.g., sun)\r\n    _lastEncounterAt?: number;\r\n};\r\n\r\nexport type StepResult = {\r\n    bodies: Body[];\r\n    events: { swingBys: Array<{ probeId: string; bodyId: string; deltaV: number; time: number }> };\r\n};\r\n\r\nfunction vecClone(v: Vec3): Vec3 {\r\n    return [v[0], v[1], v[2]];\r\n}\r\n\r\nfunction vecAdd(a: Vec3, b: Vec3): Vec3 {\r\n    return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\r\n}\r\n\r\nfunction vecSub(a: Vec3, b: Vec3): Vec3 {\r\n    return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\r\n}\r\n\r\nfunction vecScale(a: Vec3, s: number): Vec3 {\r\n    return [a[0] * s, a[1] * s, a[2] * s];\r\n}\r\n\r\nfunction vecLenSq(a: Vec3): number {\r\n    return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\r\n}\r\n\r\nfunction vecLen(a: Vec3): number {\r\n    return Math.sqrt(vecLenSq(a));\r\n}\r\n\r\nfunction vecNormalize(a: Vec3): Vec3 {\r\n    const l = vecLen(a) || 1e-12;\r\n    return [a[0] / l, a[1] / l, a[2] / l];\r\n}\r\n\r\nexport function cloneBodies(bodies: Body[]) {\r\n    return bodies.map((b) => ({ ...b, position: vecClone(b.position), velocity: vecClone(b.velocity), _lastEncounterAt: b._lastEncounterAt || 0, isStatic: b.isStatic }));\r\n}\r\n\r\n// Leapfrog / velocity-Verlet style integrator for N-body\r\nexport type SwingByOptions = {\r\n    encounterMultiplier?: number; // multiplies body.radius to form encounter distance\r\n    deltaVThreshold?: number; // minimum positive delta-v to count as swing-by\r\n    minGap?: number; // seconds before same body can trigger again\r\n};\r\n\r\nexport function stepBodies(origBodies: Body[], dt: number, G = 1.0, simTime = 0, softening = 0.1, opts?: SwingByOptions): StepResult {\r\n    const bodies = cloneBodies(origBodies);\r\n    const n = bodies.length;\r\n\r\n    // compute accelerations at current positions\r\n    const accs: Vec3[] = new Array(n).fill(0).map(() => [0, 0, 0]);\r\n\r\n    const computeAcc = (i: number, positions: Vec3[]) => {\r\n        let ax = 0,\r\n            ay = 0,\r\n            az = 0;\r\n        const pi = positions[i];\r\n        if (bodies[i].isStatic) return [0, 0, 0] as Vec3;\r\n        for (let j = 0; j < n; j++) {\r\n            if (i === j) continue;\r\n            const pj = positions[j];\r\n            const rx = pj[0] - pi[0];\r\n            const ry = pj[1] - pi[1];\r\n            const rz = pj[2] - pi[2];\r\n            const dist2 = rx * rx + ry * ry + rz * rz + softening * softening;\r\n            const invDist = 1.0 / Math.sqrt(dist2);\r\n            const invDist3 = invDist / dist2; // 1/r^3\r\n            const s = G * bodies[j].mass * invDist3;\r\n            ax += rx * s;\r\n            ay += ry * s;\r\n            az += rz * s;\r\n        }\r\n        return [ax, ay, az] as Vec3;\r\n    };\r\n\r\n    const positions = bodies.map((b) => vecClone(b.position));\r\n    for (let i = 0; i < n; i++) accs[i] = computeAcc(i, positions);\r\n\r\n    // half-step velocity\r\n    const vHalf: Vec3[] = new Array(n).fill(0).map(() => [0, 0, 0]);\r\n    for (let i = 0; i < n; i++) {\r\n        if (bodies[i].isStatic) {\r\n            vHalf[i] = vecClone(bodies[i].velocity);\r\n            continue;\r\n        }\r\n        vHalf[i] = vecAdd(bodies[i].velocity, vecScale(accs[i], dt * 0.5));\r\n        // full-step position\r\n        bodies[i].position = vecAdd(bodies[i].position, vecScale(vHalf[i], dt));\r\n    }\r\n\r\n    // accelerations at new positions\r\n    const newPositions = bodies.map((b) => vecClone(b.position));\r\n    const accsNew: Vec3[] = new Array(n).fill(0).map(() => [0, 0, 0]);\r\n    for (let i = 0; i < n; i++) accsNew[i] = computeAcc(i, newPositions);\r\n\r\n    // finish velocity\r\n    for (let i = 0; i < n; i++) {\r\n        if (bodies[i].isStatic) continue;\r\n        bodies[i].velocity = vecAdd(vHalf[i], vecScale(accsNew[i], dt * 0.5));\r\n    }\r\n\r\n    const events: StepResult['events'] = { swingBys: [] };\r\n\r\n    // swing-by detection: probe close pass and positive delta speed\r\n    for (let i = 0; i < n; i++) {\r\n        if (!bodies[i].isProbe) continue;\r\n        const probe = bodies[i];\r\n        const speedBefore = vecLen(vHalf[i]);\r\n        const speedAfter = vecLen(probe.velocity);\r\n        for (let j = 0; j < n; j++) {\r\n            if (i === j) continue;\r\n            const other = bodies[j];\r\n            if (other.mass < 1e-6) continue;\r\n            const rx = probe.position[0] - other.position[0];\r\n            const ry = probe.position[1] - other.position[1];\r\n            const rz = probe.position[2] - other.position[2];\r\n            const dist = Math.sqrt(rx * rx + ry * ry + rz * rz);\r\n            const encounterMultiplier = opts?.encounterMultiplier ?? 2.5;\r\n            const deltaVThreshold = opts?.deltaVThreshold ?? 0.05;\r\n            const gap = opts?.minGap ?? 0.5;\r\n            const encounterRadius = Math.max((other.radius || 1) * encounterMultiplier, 1.0);\r\n            const lastAt = other._lastEncounterAt || 0;\r\n            if (dist <= encounterRadius && simTime - lastAt > gap) {\r\n                const deltaV = speedAfter - speedBefore;\r\n                if (deltaV > deltaVThreshold) {\r\n                    events.swingBys.push({ probeId: probe.id, bodyId: other.id, deltaV, time: simTime });\r\n                    other._lastEncounterAt = simTime;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return { bodies, events };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"sources":["file:///D:/my_projects/space-probe-game-next/space-probe-game-next/src/lib/threeSetup.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { Body, cloneBodies, stepBodies } from './physics';\r\n\r\n// ====================================================================\r\n// Physics Scale Factors and Units\r\n// ====================================================================\r\n// This simulation uses a scaled unit system for game playability:\r\n// - Mass: Earth mass = 1.0, Sun mass = 333,000 (realistic ratio)\r\n// - Distance: 1 AU = 100 scene units\r\n// - Time: Accelerated by factor of ~1,000,000 (1 real second ≈ 11.6 simulation days)\r\n// - This gives Earth orbital period of ~30 seconds (vs 365 days in reality)\r\n// ====================================================================\r\n\r\nexport const PHYSICS_SCALE = {\r\n    // Mass scale: Earth mass = 1.0\r\n    EARTH_MASS: 1.0,\r\n    SUN_MASS: 333000,  // Realistic Sun/Earth mass ratio\r\n\r\n    // Distance scale: 1 AU = 100 scene units\r\n    AU: 100,\r\n\r\n    // Time scale: ~1 million times faster than reality\r\n    // (Earth completes orbit in ~30 seconds instead of 365 days)\r\n    TIME_SCALE: 1e6,\r\n\r\n    // Gravity constant adjusted for our unit system\r\n    // This value gives realistic orbital mechanics with scaled time\r\n    G: 0.133,\r\n\r\n    // Velocity conversion: scene units/sec to km/s\r\n    // Based on Earth orbital velocity: ~21 scene units/sec = 30 km/s (real)\r\n    VELOCITY_TO_KM_PER_SEC: 1.43,  // multiply scene velocity by this to get km/s\r\n\r\n    // Fuel consumption rate: % consumed per unit delta-v\r\n    // With dvScale = 0.02, single direction thrust consumes 0.02% per frame\r\n    // Total fuel = 100%, allows ~5000 frames (~83 seconds at 60fps) of continuous thrust\r\n    FUEL_CONSUMPTION_RATE: 1.0,\r\n};\r\n\r\n// Legacy constant for backward compatibility\r\nexport const DEFAULT_G = PHYSICS_SCALE.G;\r\n\r\nexport type ProbeState = {\r\n    position: THREE.Vector3;\r\n    velocity: THREE.Vector3; // vector velocity in scene units/sec\r\n    distance: number; // accumulated path length\r\n    fuel: number; // percent\r\n    slingshots: number;\r\n    status: string;\r\n};\r\n\r\nexport function initThreeJS(canvas: HTMLCanvasElement, options?: { probeSpeedMult?: number; G?: number; starMass?: number }) {\r\n    const scene = new THREE.Scene();\r\n    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 50000);\r\n    camera.position.set(0, 400, 2200);\r\n\r\n    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\r\n\r\n    const ambient = new THREE.AmbientLight(0xffffff, 0.6);\r\n    scene.add(ambient);\r\n    const directional = new THREE.DirectionalLight(0xffffff, 0.8);\r\n    directional.position.set(5, 10, 7.5);\r\n    scene.add(directional);\r\n\r\n    // Simple grid for reference (large enough to show outer planets)\r\n    const grid = new THREE.GridHelper(7000, 140, 0x444444, 0x222222);\r\n    scene.add(grid);\r\n\r\n    // Create a list of bodies: central star, planets, probe\r\n    const bodies: Body[] = [];\r\n    const planetMeshes: { id: string; mesh: THREE.Mesh }[] = [];\r\n\r\n    // central star at origin (can be overridden via options)\r\n    const starMass = options?.starMass ?? PHYSICS_SCALE.SUN_MASS;\r\n    const starGeom = new THREE.SphereGeometry(5, 24, 24);\r\n    const starMat = new THREE.MeshStandardMaterial({ color: 0xffee88, emissive: 0x220000 });\r\n    const starMesh = new THREE.Mesh(starGeom, starMat);\r\n    starMesh.position.set(0, 0, 0);\r\n    scene.add(starMesh);\r\n    // allow the star to move under gravity (we'll initialize COM-zero velocities below)\r\n    bodies.push({ id: 'star', mass: starMass, position: [0, 0, 0], velocity: [0, 0, 0], radius: 5, isProbe: false });\r\n\r\n    // Solar system-like planets (units: 1 AU = 100 scene units)\r\n    const AU = PHYSICS_SCALE.AU;\r\n    const solarDefs = [\r\n        { id: 'Mercury', rAU: 0.39, radius: 3, color: 0xaaaaaa, phase: 0, mass: 0.055 },\r\n        { id: 'Venus',   rAU: 0.72, radius: 5, color: 0xffddaa, phase: 0.5, mass: 0.815 },\r\n        { id: 'Earth',   rAU: 1.00, radius: 5.5, color: 0x3366ff, phase: 1.0, mass: 1.0 },\r\n        { id: 'Mars',    rAU: 1.52, radius: 4, color: 0xff6633, phase: 1.6, mass: 0.107 },\r\n        { id: 'Jupiter', rAU: 5.20, radius: 14, color: 0xffcc77, phase: 2.2, mass: 317.8 },\r\n        { id: 'Saturn',  rAU: 9.58, radius: 12, color: 0xffee88, phase: 3.0, mass: 95.16 },\r\n        { id: 'Uranus',  rAU:19.20, radius: 9, color: 0x88ccff, phase: 4.0, mass: 14.5 },\r\n        { id: 'Neptune', rAU:30.05, radius: 9, color: 0x3366aa, phase: 5.0, mass: 17.1 },\r\n    ];\r\n\r\n    const starMassScaled = starMass; // use starMass as mass scale\r\n    for (const pd of solarDefs) {\r\n        const pdR = pd.rAU * AU;\r\n        const geom = new THREE.SphereGeometry(pd.radius, 16, 16);\r\n        const mat = new THREE.MeshStandardMaterial({ color: pd.color });\r\n        const mesh = new THREE.Mesh(geom, mat);\r\n        const x = Math.sin(pd.phase) * pdR;\r\n        const z = Math.cos(pd.phase) * pdR;\r\n        mesh.position.set(x, 0, z);\r\n        scene.add(mesh);\r\n        planetMeshes.push({ id: pd.id, mesh });\r\n    const gVal = options?.G ?? DEFAULT_G;\r\n    const v = Math.sqrt((gVal * starMassScaled) / pdR);\r\n        const vx = v * Math.cos(pd.phase);\r\n        const vz = -v * Math.sin(pd.phase);\r\n        bodies.push({ id: pd.id, mass: pd.mass, position: [x, 0, z], velocity: [vx, 0, vz], radius: pd.radius });\r\n    }\r\n\r\n    // probe initial (starts at 1.0 AU - Earth orbit distance)\r\n    const probeGeom = new THREE.SphereGeometry(0.6, 10, 10);\r\n    const probeMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });\r\n    const probe = new THREE.Mesh(probeGeom, probeMat);\r\n    const probeR = 100;  // 1.0 AU (same as Earth orbit)\r\n    probe.position.set(0, 0, probeR);\r\n    scene.add(probe);\r\n    const gVal = options?.G ?? DEFAULT_G;\r\n    const probeMult = options?.probeSpeedMult ?? 1.05;  // Realistic escape velocity (5% above circular)\r\n    const vCircular = Math.sqrt((gVal * starMass) / probeR);\r\n    const probeBody: Body = { id: 'probe', mass: 1, position: [0, 0, probeR], velocity: [vCircular * probeMult, 0, 0], radius: 0.6, isProbe: true };\r\n    bodies.push(probeBody);\r\n\r\n    // --- CENTER-OF-MASS (COM) velocity zeroing ---\r\n    // After creating all bodies, compute total momentum and apply a uniform\r\n    // velocity offset so total momentum is zero. This keeps the system's\r\n    // center-of-mass stationary while allowing the star to move.\r\n    (function zeroCOM() {\r\n        let totalPx = 0, totalPy = 0, totalPz = 0;\r\n        let totalMass = 0;\r\n        for (const b of bodies) {\r\n            totalPx += b.mass * b.velocity[0];\r\n            totalPy += b.mass * b.velocity[1];\r\n            totalPz += b.mass * b.velocity[2];\r\n            totalMass += b.mass;\r\n        }\r\n        if (totalMass > 0) {\r\n            const vx = totalPx / totalMass;\r\n            const vy = totalPy / totalMass;\r\n            const vz = totalPz / totalMass;\r\n            // subtract COM velocity from each body so net momentum becomes zero\r\n            for (const b of bodies) {\r\n                b.velocity[0] -= vx;\r\n                b.velocity[1] -= vy;\r\n                b.velocity[2] -= vz;\r\n            }\r\n            console.log('COM-zero velocity applied, offset:', vx.toFixed(6), vy.toFixed(6), vz.toFixed(6));\r\n        }\r\n    })();\r\n\r\n    // (COM position zeroing will be performed once after state is created)\r\n\r\n    // OrbitControls for interactive camera\r\n    const controls = new OrbitControls(camera, renderer.domElement);\r\n    controls.enableDamping = true;\r\n    controls.dampingFactor = 0.05;\r\n    controls.enablePan = true;\r\n    controls.update();\r\n\r\n    // ====================================================================\r\n    // Star Field for Speed Sensation\r\n    // ====================================================================\r\n    // Create background stars with color variation for visual depth\r\n    function createStarField() {\r\n        const starCount = 8000;\r\n        const starGeometry = new THREE.BufferGeometry();\r\n        const starPositions = new Float32Array(starCount * 3);\r\n        const starColors = new Float32Array(starCount * 3);\r\n\r\n        for (let i = 0; i < starCount; i++) {\r\n            // Position: random spherical distribution\r\n            const radius = 5000 + Math.random() * 10000; // 5000-15000 range\r\n            const theta = Math.random() * Math.PI * 2;   // 0-2π\r\n            const phi = Math.acos(2 * Math.random() - 1); // 0-π (uniform sphere)\r\n\r\n            starPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);\r\n            starPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\r\n            starPositions[i * 3 + 2] = radius * Math.cos(phi);\r\n\r\n            // Color: mostly white, occasionally bluish or yellowish\r\n            const colorChoice = Math.random();\r\n            if (colorChoice < 0.7) {\r\n                // White\r\n                starColors[i * 3] = 1;\r\n                starColors[i * 3 + 1] = 1;\r\n                starColors[i * 3 + 2] = 1;\r\n            } else if (colorChoice < 0.85) {\r\n                // Bluish white\r\n                starColors[i * 3] = 0.8;\r\n                starColors[i * 3 + 1] = 0.9;\r\n                starColors[i * 3 + 2] = 1;\r\n            } else {\r\n                // Yellowish white\r\n                starColors[i * 3] = 1;\r\n                starColors[i * 3 + 1] = 0.95;\r\n                starColors[i * 3 + 2] = 0.8;\r\n            }\r\n        }\r\n\r\n        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));\r\n        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));\r\n\r\n        const starMaterial = new THREE.PointsMaterial({\r\n            size: 2,\r\n            vertexColors: true,\r\n            sizeAttenuation: true,\r\n            transparent: true,\r\n            opacity: 0.8\r\n        });\r\n\r\n        const stars = new THREE.Points(starGeometry, starMaterial);\r\n        scene.add(stars);\r\n    }\r\n\r\n    createStarField();\r\n\r\n    // Trail (orbit path) - sample points stored as Vector3 and rendered smooth via Catmull-Rom\r\n    const trailPoints: THREE.Vector3[] = [];\r\n    const trailGeometry = new THREE.BufferGeometry();\r\n    const trailMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88 });\r\n    const trailLine = new THREE.Line(trailGeometry, trailMaterial);\r\n    scene.add(trailLine);\r\n\r\n    function addTrailPoint(p: THREE.Vector3) {\r\n        const maxPoints = 2000;\r\n        trailPoints.push(p.clone());\r\n        if (trailPoints.length > maxPoints) {\r\n            trailPoints.shift();\r\n        }\r\n\r\n        if (trailPoints.length >= 2) {\r\n            const curve = new THREE.CatmullRomCurve3(trailPoints, false, 'catmullrom', 0.5);\r\n            const divisions = Math.min(Math.max(trailPoints.length * 6, 64), 3000);\r\n            const smoothPoints = curve.getPoints(divisions);\r\n            const positions: number[] = [];\r\n            for (let i = 0; i < smoothPoints.length; i++) {\r\n                positions.push(smoothPoints[i].x, smoothPoints[i].y, smoothPoints[i].z);\r\n            }\r\n            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n            trailGeometry.setDrawRange(0, positions.length / 3);\r\n            trailGeometry.computeBoundingSphere();\r\n        }\r\n    }\r\n\r\n    // ====================================================================\r\n    // Velocity Vector Visualization\r\n    // ====================================================================\r\n    // Display probe's velocity as an arrow (direction and magnitude)\r\n    const velocityArrow = new THREE.ArrowHelper(\r\n        new THREE.Vector3(1, 0, 0), // initial direction\r\n        probe.position,              // origin\r\n        10,                          // length\r\n        0xff0000,                    // color (red)\r\n        3,                           // head length\r\n        2                            // head width\r\n    );\r\n    scene.add(velocityArrow);\r\n\r\n    function updateVelocityArrow() {\r\n        const speed = state.velocity.length();\r\n        if (speed > 0.001) {\r\n            const direction = state.velocity.clone().normalize();\r\n            velocityArrow.setDirection(direction);\r\n            // Scale arrow length with speed (but cap at reasonable size)\r\n            const arrowLength = Math.min(speed * 2, 50);\r\n            velocityArrow.setLength(arrowLength, 3, 2);\r\n\r\n            // Color based on speed (blue -> green -> yellow -> red)\r\n            const speedRatio = Math.min(speed / 50, 1); // normalize to 0-1\r\n            if (speedRatio < 0.33) {\r\n                // Blue to green\r\n                const t = speedRatio / 0.33;\r\n                velocityArrow.setColor(new THREE.Color(0, t, 1 - t));\r\n            } else if (speedRatio < 0.66) {\r\n                // Green to yellow\r\n                const t = (speedRatio - 0.33) / 0.33;\r\n                velocityArrow.setColor(new THREE.Color(t, 1, 0));\r\n            } else {\r\n                // Yellow to red\r\n                const t = (speedRatio - 0.66) / 0.34;\r\n                velocityArrow.setColor(new THREE.Color(1, 1 - t, 0));\r\n            }\r\n\r\n            velocityArrow.position.copy(state.position);\r\n            velocityArrow.visible = true;\r\n        } else {\r\n            velocityArrow.visible = false;\r\n        }\r\n    }\r\n\r\n    // ====================================================================\r\n    // Swing-by Influence Zones Visualization\r\n    // ====================================================================\r\n    // Display encounter radius around each planet as a torus (donut ring)\r\n    const influenceZones: THREE.Mesh[] = [];\r\n\r\n    for (const pm of planetMeshes) {\r\n        const planetData = solarDefs.find(pd => pd.id === pm.id);\r\n        if (!planetData) continue;\r\n\r\n        const encounterRadius = planetData.radius * 2.5; // encounterMultiplier\r\n\r\n        // Create torus (ring)\r\n        const torusGeometry = new THREE.TorusGeometry(\r\n            encounterRadius,           // radius\r\n            encounterRadius * 0.08,    // tube thickness (8% of radius)\r\n            8,                         // radial segments\r\n            64                         // tubular segments\r\n        );\r\n\r\n        const torusMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0x00ff00,\r\n            transparent: true,\r\n            opacity: 0.25,\r\n            side: THREE.DoubleSide\r\n        });\r\n\r\n        const torus = new THREE.Mesh(torusGeometry, torusMaterial);\r\n        // Rotate to align with XZ plane (horizontal)\r\n        torus.rotation.x = Math.PI / 2;\r\n        torus.position.copy(pm.mesh.position);\r\n        scene.add(torus);\r\n        influenceZones.push(torus);\r\n\r\n        // Store reference for updating position\r\n        (pm as any).influenceZone = torus;\r\n    }\r\n\r\n    // ====================================================================\r\n    // Planetary Orbit Visualization\r\n    // ====================================================================\r\n    // Display circular orbits for each planet\r\n    const orbitLines: THREE.Line[] = [];\r\n\r\n    for (const pd of solarDefs) {\r\n        const orbitRadius = pd.rAU * AU;\r\n        const segments = 128; // Number of points in the circle\r\n        const points: THREE.Vector3[] = [];\r\n\r\n        // Create circle points\r\n        for (let i = 0; i <= segments; i++) {\r\n            const theta = (i / segments) * Math.PI * 2;\r\n            const x = Math.cos(theta) * orbitRadius;\r\n            const z = Math.sin(theta) * orbitRadius;\r\n            points.push(new THREE.Vector3(x, 0, z));\r\n        }\r\n\r\n        // Create line geometry\r\n        const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);\r\n        const orbitMaterial = new THREE.LineBasicMaterial({\r\n            color: pd.color,\r\n            transparent: true,\r\n            opacity: 0.3,\r\n            linewidth: 1\r\n        });\r\n\r\n        const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);\r\n        scene.add(orbitLine);\r\n        orbitLines.push(orbitLine);\r\n    }\r\n\r\n    // ====================================================================\r\n    // Predicted Trajectory Visualization (Phase 2)\r\n    // ====================================================================\r\n    // Display future trajectory based on current velocity and gravity\r\n    const predictionPoints: THREE.Vector3[] = [];\r\n    const predictionGeometry = new THREE.BufferGeometry();\r\n    const predictionMaterial = new THREE.LineDashedMaterial({\r\n        color: 0xffaa00,\r\n        dashSize: 3,\r\n        gapSize: 2,\r\n        linewidth: 1,\r\n        transparent: true,\r\n        opacity: 0.6\r\n    });\r\n    const predictionLine = new THREE.Line(predictionGeometry, predictionMaterial);\r\n    scene.add(predictionLine);\r\n\r\n    // Success prediction indicators (text sprites near planets)\r\n    const successIndicators: { planetId: string; mesh: THREE.Sprite; probability: number }[] = [];\r\n\r\n    function createTextSprite(text: string, color: number = 0xffffff): THREE.Sprite {\r\n        const canvas = document.createElement('canvas');\r\n        const context = canvas.getContext('2d')!;\r\n        canvas.width = 256;\r\n        canvas.height = 128;\r\n        context.font = 'Bold 48px Arial';\r\n        context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;\r\n        context.textAlign = 'center';\r\n        context.textBaseline = 'middle';\r\n        context.fillText(text, 128, 64);\r\n\r\n        const texture = new THREE.CanvasTexture(canvas);\r\n        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });\r\n        const sprite = new THREE.Sprite(spriteMaterial);\r\n        sprite.scale.set(20, 10, 1);\r\n        return sprite;\r\n    }\r\n\r\n    // Create success indicators for each planet\r\n    for (const pm of planetMeshes) {\r\n        const sprite = createTextSprite('', 0x00ff00);\r\n        sprite.visible = false;\r\n        scene.add(sprite);\r\n        successIndicators.push({ planetId: pm.id, mesh: sprite, probability: 0 });\r\n    }\r\n\r\n    let lastPredictionUpdate = 0;\r\n    const predictionUpdateInterval = 500; // Update every 500ms\r\n\r\n    function updatePredictedTrajectory() {\r\n        const now = performance.now();\r\n        if (now - lastPredictionUpdate < predictionUpdateInterval) return;\r\n        lastPredictionUpdate = now;\r\n\r\n        // Clone current bodies state for prediction\r\n        const predictedBodies = cloneBodies(bodies);\r\n        const probeIndex = predictedBodies.findIndex(b => b.id === 'probe');\r\n        if (probeIndex < 0) return;\r\n\r\n        // Run simulation forward for predictionTime seconds\r\n        const predictionTime = 15; // seconds\r\n        const predictionSteps = 150; // number of points\r\n        const dt = predictionTime / predictionSteps;\r\n\r\n        predictionPoints.length = 0;\r\n        predictionPoints.push(new THREE.Vector3(\r\n            predictedBodies[probeIndex].position[0],\r\n            predictedBodies[probeIndex].position[1],\r\n            predictedBodies[probeIndex].position[2]\r\n        ));\r\n\r\n        // Reset success probabilities\r\n        for (const indicator of successIndicators) {\r\n            indicator.probability = 0;\r\n        }\r\n\r\n        const gRun = options?.G ?? DEFAULT_G;\r\n        let predSimTime = simTime;\r\n\r\n        // Simulate future trajectory\r\n        for (let i = 0; i < predictionSteps; i++) {\r\n            const { bodies: nextBodies, events } = stepBodies(predictedBodies, dt, gRun, predSimTime, 0.5, swingOptions);\r\n            predSimTime += dt;\r\n\r\n            // Copy nextBodies back to predictedBodies (safely handle type)\r\n            for (let j = 0; j < nextBodies.length; j++) {\r\n                predictedBodies[j] = { ...nextBodies[j] } as any;\r\n            }\r\n\r\n            // Store probe position\r\n            const probePos = predictedBodies[probeIndex].position;\r\n            predictionPoints.push(new THREE.Vector3(probePos[0], probePos[1], probePos[2]));\r\n\r\n            // Check for predicted swing-bys\r\n            if (events && events.swingBys && events.swingBys.length > 0) {\r\n                for (const ev of events.swingBys) {\r\n                    if (ev.probeId === 'probe') {\r\n                        const indicator = successIndicators.find(ind => ind.planetId === ev.bodyId);\r\n                        if (indicator) {\r\n                            // Calculate success probability based on deltaV\r\n                            const probability = Math.min(ev.deltaV / 1.0, 1.0) * 100;\r\n                            indicator.probability = Math.max(indicator.probability, probability);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update prediction line geometry\r\n        if (predictionPoints.length >= 2) {\r\n            const positions: number[] = [];\r\n            for (const point of predictionPoints) {\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n            predictionGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n            predictionGeometry.computeBoundingSphere();\r\n            predictionLine.computeLineDistances(); // Required for dashed lines\r\n            predictionLine.visible = true;\r\n        } else {\r\n            predictionLine.visible = false;\r\n        }\r\n\r\n        // Update success indicators\r\n        for (const indicator of successIndicators) {\r\n            if (indicator.probability > 0) {\r\n                const pm = planetMeshes.find(p => p.id === indicator.planetId);\r\n                if (pm) {\r\n                    // Position indicator above planet\r\n                    const planetData = solarDefs.find(pd => pd.id === indicator.planetId);\r\n                    const offset = planetData ? planetData.radius * 4 : 30;\r\n                    indicator.mesh.position.set(\r\n                        pm.mesh.position.x,\r\n                        pm.mesh.position.y + offset,\r\n                        pm.mesh.position.z\r\n                    );\r\n\r\n                    // Update text based on probability\r\n                    const probabilityText = `${Math.round(indicator.probability)}%`;\r\n                    const color = indicator.probability > 70 ? 0x00ff00 :\r\n                                  indicator.probability > 40 ? 0xffaa00 : 0xff0000;\r\n\r\n                    // Update sprite texture\r\n                    const canvas = document.createElement('canvas');\r\n                    const context = canvas.getContext('2d')!;\r\n                    canvas.width = 256;\r\n                    canvas.height = 128;\r\n                    context.font = 'Bold 48px Arial';\r\n                    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;\r\n                    context.textAlign = 'center';\r\n                    context.textBaseline = 'middle';\r\n                    context.fillText(probabilityText, 128, 64);\r\n\r\n                    const texture = new THREE.CanvasTexture(canvas);\r\n                    indicator.mesh.material.map = texture;\r\n                    indicator.mesh.material.needsUpdate = true;\r\n                    indicator.mesh.visible = true;\r\n                }\r\n            } else {\r\n                indicator.mesh.visible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Simulation state derived from bodies: expose probe state for HUD and visual sync\r\n    const state: ProbeState = {\r\n        position: probe.position.clone(),\r\n        velocity: new THREE.Vector3(probeBody.velocity[0], probeBody.velocity[1], probeBody.velocity[2]),\r\n        distance: 0,\r\n        fuel: 100,\r\n        slingshots: 0,\r\n        status: 'Idle',\r\n    };\r\n\r\n    // --- CENTER-OF-MASS (COM) position zeroing ---\r\n    // Shift all body positions so that the initial center-of-mass position is at the origin.\r\n    (function zeroCOMPosition() {\r\n        let mx = 0, my = 0, mz = 0;\r\n        let totalMass = 0;\r\n        for (const b of bodies) {\r\n            mx += b.mass * b.position[0];\r\n            my += b.mass * b.position[1];\r\n            mz += b.mass * b.position[2];\r\n            totalMass += b.mass;\r\n        }\r\n        if (totalMass > 0) {\r\n            const cx = mx / totalMass;\r\n            const cy = my / totalMass;\r\n            const cz = mz / totalMass;\r\n            // subtract COM position from each body's position\r\n            for (const b of bodies) {\r\n                b.position[0] -= cx;\r\n                b.position[1] -= cy;\r\n                b.position[2] -= cz;\r\n            }\r\n            // adjust visual meshes to match new positions\r\n            try {\r\n                starMesh.position.set(bodies.find((b) => b.id === 'star')!.position[0], bodies.find((b) => b.id === 'star')!.position[1], bodies.find((b) => b.id === 'star')!.position[2]);\r\n                for (const pm of planetMeshes) {\r\n                    const b = bodies.find((bb) => bb.id === pm.id);\r\n                    if (b) pm.mesh.position.set(b.position[0], b.position[1], b.position[2]);\r\n                }\r\n                // probe\r\n                const pb = bodies.find((b) => b.id === 'probe');\r\n                if (pb) {\r\n                    probe.position.set(pb.position[0], pb.position[1], pb.position[2]);\r\n                    state.position.copy(probe.position);\r\n                }\r\n            } catch (e) {\r\n                // ignore if meshes not ready\r\n            }\r\n            console.log('COM-zero position applied:', cx.toFixed(3), cy.toFixed(3), cz.toFixed(3));\r\n        }\r\n    })();\r\n\r\n    function onResize() {\r\n        camera.aspect = window.innerWidth / window.innerHeight;\r\n        camera.updateProjectionMatrix();\r\n        renderer.setSize(window.innerWidth, window.innerHeight);\r\n        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\r\n    }\r\n\r\n    window.addEventListener('resize', onResize);\r\n\r\n    let simTime = 0;\r\n\r\n    // swing-by tuning options (tweak these values)\r\n    // With realistic Sun/planet mass ratios, swing-by effects are smaller for inner planets\r\n    // but significant for gas giants (Jupiter, Saturn). Threshold adjusted accordingly.\r\n    const swingOptions = {\r\n        encounterMultiplier: 2.5,   // Slightly wider detection radius\r\n        deltaVThreshold: 0.01,      // Lower threshold to catch smaller effects (was 0.03)\r\n        minGap: 0.4                 // Shorter cooldown between detections\r\n    };\r\n\r\n    // simple visual markers for swing-by events\r\n    const eventMarkers: THREE.Mesh[] = [];\r\n\r\n    function stepSimulation(dt: number) {\r\n        // call physics.stepBodies with plain-data bodies\r\n        const gRun = options?.G ?? DEFAULT_G;\r\n        const { bodies: nextBodies, events } = stepBodies(bodies, dt, gRun, simTime, 0.5, swingOptions);\r\n        simTime += dt;\r\n\r\n        // apply nextBodies back to visuals and local bodies\r\n        for (const nb of nextBodies) {\r\n                const idx = bodies.findIndex((b) => b.id === nb.id);\r\n                // if the body is marked static (e.g., the central star), don't overwrite its position\r\n                const orig = idx >= 0 ? bodies[idx] : null;\r\n                if (idx >= 0 && !orig?.isStatic) {\r\n                    bodies[idx] = nb;\r\n                }\r\n            // apply to mesh\r\n            if (nb.id === 'probe') {\r\n                probe.position.set(nb.position[0], nb.position[1], nb.position[2]);\r\n                state.position.copy(probe.position);\r\n                state.velocity.set(nb.velocity[0], nb.velocity[1], nb.velocity[2]);\r\n                // accumulate distance -- simple approximation\r\n                state.distance += vecLen([nb.velocity[0] * dt, nb.velocity[1] * dt, nb.velocity[2] * dt]);\r\n                // Update status: check fuel first, then velocity\r\n                if (state.fuel <= 0) {\r\n                    state.status = 'Fuel Depleted';\r\n                } else {\r\n                    state.status = state.velocity.length() > 1e-3 ? 'Running' : 'Idle';\r\n                }\r\n            }\r\n            // update planet meshes (check if this body's id is in planetMeshes array)\r\n            const pm = planetMeshes.find((p) => p.id === nb.id);\r\n            if (pm) {\r\n                pm.mesh.position.set(nb.position[0], nb.position[1], nb.position[2]);\r\n                // Update influence zone position to match planet\r\n                if ((pm as any).influenceZone) {\r\n                    (pm as any).influenceZone.position.copy(pm.mesh.position);\r\n                }\r\n            }\r\n            // (star is now movable) synchronize star mesh to its simulated position\r\n            if (nb.id === 'star') {\r\n                starMesh.position.set(nb.position[0], nb.position[1], nb.position[2]);\r\n            }\r\n        }\r\n\r\n        // Update velocity arrow visualization\r\n        updateVelocityArrow();\r\n\r\n        // Update predicted trajectory (Phase 2)\r\n        updatePredictedTrajectory();\r\n\r\n        // handle events (swing-bys)\r\n        if (events && events.swingBys && events.swingBys.length) {\r\n            for (const ev of events.swingBys) {\r\n                if (ev.probeId === 'probe') {\r\n                    state.slingshots += 1;\r\n                    console.log(`Swing-by detected at t=${ev.time.toFixed(2)}: probe around ${ev.bodyId} deltaV=${ev.deltaV.toFixed(3)}`);\r\n                    // find body position for marker\r\n                    const body = nextBodies.find((b) => b.id === ev.bodyId);\r\n                    if (body) {\r\n                        const markerGeom = new THREE.SphereGeometry(0.8, 8, 8);\r\n                        const markerMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n                        const marker = new THREE.Mesh(markerGeom, markerMat);\r\n                        marker.position.set(body.position[0], body.position[1], body.position[2]);\r\n                        scene.add(marker);\r\n                        eventMarkers.push(marker);\r\n                        // fade out marker after 1.2s\r\n                        setTimeout(() => {\r\n                            scene.remove(marker);\r\n                            const i = eventMarkers.indexOf(marker);\r\n                            if (i >= 0) eventMarkers.splice(i, 1);\r\n                        }, 1200);\r\n                    }\r\n                    // flash probe material if available\r\n                    try {\r\n                        const mat: any = probe.material;\r\n                        if (mat && mat.emissive) {\r\n                            const prev = mat.emissive.clone ? mat.emissive.clone() : null;\r\n                            mat.emissive.setHex(0xff4444);\r\n                            setTimeout(() => {\r\n                                if (prev && mat.emissive && mat.emissive.set) mat.emissive.copy(prev);\r\n                            }, 500);\r\n                        }\r\n                    } catch (e) {\r\n                        // ignore material issues\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // bind the exported applyDeltaVToProbe to modify the local bodies array\r\n    (function bindApply() {\r\n        const mod = (dv: [number, number, number]) => {\r\n            const idx = bodies.findIndex((b) => b.id === 'probe');\r\n            if (idx >= 0) {\r\n                bodies[idx].velocity[0] += dv[0];\r\n                bodies[idx].velocity[1] += dv[1];\r\n                bodies[idx].velocity[2] += dv[2];\r\n            }\r\n        };\r\n        try {\r\n            // expose on window so consumer code in GameCanvas can call it reliably\r\n            (window as any).__applyDeltaVToProbe = mod;\r\n        } catch (e) {\r\n            // ignore if window isn't available\r\n        }\r\n    })();\r\n\r\n    function dispose() {\r\n        window.removeEventListener('resize', onResize);\r\n        renderer.dispose();\r\n        scene.traverse((obj: any) => {\r\n            if (obj.geometry) obj.geometry.dispose?.();\r\n            if (obj.material) {\r\n                const mat = obj.material as any;\r\n                if (Array.isArray(mat)) mat.forEach((m) => m.dispose && m.dispose());\r\n                else mat.dispose && mat.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    return { scene, camera, renderer, dispose, state, probe, controls, addTrailPoint, stepSimulation };\r\n}\r\n\r\n// small helper to allow external callers to apply delta-v to the probe\r\n// We'll export a typed wrapper that others can call if they capture the\r\n// init's return value; but for convenience also provide this function\r\n// that will be replaced when initThreeJS is called.\r\nexport function applyDeltaVToProbe(_dv: [number, number, number]) {\r\n    // no-op placeholder; actual implementation bound in initThreeJS's closure\r\n    console.warn('applyDeltaVToProbe called before init; ignoring');\r\n}\r\n\r\n// small helper to compute vector length for [x,y,z]\r\nfunction vecLen(v: [number, number, number]) {\r\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\r\n}\r\n\r\nexport default initThreeJS;\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 954, "column": 0}, "map": {"version":3,"sources":["file:///D:/my_projects/space-probe-game-next/space-probe-game-next/src/components/GameCanvas.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { useEffect, useRef } from 'react';\nimport { initThreeJS, PHYSICS_SCALE } from '../lib/threeSetup';\nimport { CameraView } from './Controls';\n\ntype HUDSetters = {\n    setStatus: React.Dispatch<React.SetStateAction<string>>;\n    setVelocity: React.Dispatch<React.SetStateAction<number>>;\n    setDistance: React.Dispatch<React.SetStateAction<number>>;\n    setFuel: React.Dispatch<React.SetStateAction<number>>;\n    setSlingshots: React.Dispatch<React.SetStateAction<number>>;\n};\n\ninterface Props {\n    hudSetters?: HUDSetters;\n    probeSpeedMult?: number;\n    gravityG?: number;\n    starMass?: number;\n    cameraView?: CameraView;\n}\n\nconst GameCanvas: React.FC<Props> = ({ hudSetters, probeSpeedMult = 1.05, gravityG = 1.0, starMass = 4000, cameraView = 'free' }) => {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\n    const rafRef = useRef<number | null>(null);\n    const cameraViewRef = useRef<CameraView>(cameraView);\n\n    // Update cameraViewRef when cameraView changes\n    useEffect(() => {\n        cameraViewRef.current = cameraView;\n    }, [cameraView]);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n    const hudUpdateRef = { current: undefined as any } as React.MutableRefObject<any>;\n    const trailRef = { current: undefined as any } as React.MutableRefObject<any>;\n\n    // pass simulation tuning options to initThreeJS\n    let threeObj: any = (initThreeJS as any)(canvas, { probeSpeedMult, G: gravityG, starMass });\n    let { scene, camera, renderer, dispose, state, probe, controls, addTrailPoint, stepSimulation } = threeObj;\n\n    // input state\n    const inputState = { left: false, right: false, up: false, down: false } as any;\n\n    const onKeyDown = (e: KeyboardEvent) => {\n        if (e.key === 'ArrowLeft') inputState.left = true;\n        if (e.key === 'ArrowRight') inputState.right = true;\n        if (e.key === 'ArrowUp') inputState.up = true;\n        if (e.key === 'ArrowDown') inputState.down = true;\n        if (e.key === 'r' || e.key === 'R') {\n            // restart: dispose and reinit\n            try {\n                if (rafRef.current) cancelAnimationFrame(rafRef.current);\n            } catch (e) {}\n            try {\n                dispose();\n            } catch (e) {}\n            threeObj = (initThreeJS as any)(canvas, { probeSpeedMult, G: gravityG, starMass });\n            ({ scene, camera, renderer, dispose, state, probe, controls, addTrailPoint, stepSimulation } = threeObj);\n            // Restart animation loop\n            lastTime = performance.now() / 1000;\n            accumulator = 0;\n            rafRef.current = requestAnimationFrame(animate);\n        }\n    };\n\n    const onKeyUp = (e: KeyboardEvent) => {\n        if (e.key === 'ArrowLeft') inputState.left = false;\n        if (e.key === 'ArrowRight') inputState.right = false;\n        if (e.key === 'ArrowUp') inputState.up = false;\n        if (e.key === 'ArrowDown') inputState.down = false;\n    };\n\n    window.addEventListener('keydown', onKeyDown);\n    window.addEventListener('keyup', onKeyUp);\n\n        // Fixed timestep physics loop (e.g., 60 Hz)\n        const fixedTimeStep = 1 / 60; // seconds\n        let accumulator = 0;\n        let lastTime = performance.now() / 1000;\n\n        const animate = () => {\n            const now = performance.now() / 1000;\n            let delta = now - lastTime;\n            lastTime = now;\n\n            // clamp delta to avoid spiral of death\n            if (delta > 0.25) delta = 0.25;\n\n            accumulator += delta;\n            while (accumulator >= fixedTimeStep) {\n                try {\n                    // apply input-driven delta-v before stepping\n                    const dvScale = 0.02; // tune this for feel (scene-units/sec)\n                    let dv: [number, number, number] = [0, 0, 0];\n\n                    // Calculate thrust direction based on current velocity (velocity-relative control)\n                    if (state && state.velocity) {\n                        const vx = state.velocity.x;\n                        const vy = state.velocity.y;\n                        const vz = state.velocity.z;\n                        const speed = Math.sqrt(vx * vx + vy * vy + vz * vz);\n\n                        if (speed > 0.001) {\n                            // Normalize velocity to get forward direction\n                            const fx = vx / speed;\n                            const fy = vy / speed;\n                            const fz = vz / speed;\n\n                            // Calculate right direction (cross product with up vector [0,1,0])\n                            // right = cross(forward, up) = [fz, 0, -fx]\n                            const rx = fz;\n                            const ry = 0;\n                            const rz = -fx;\n\n                            // Normalize right vector\n                            const rLen = Math.sqrt(rx * rx + rz * rz);\n                            const rnx = rLen > 0.001 ? rx / rLen : 1;\n                            const rnz = rLen > 0.001 ? rz / rLen : 0;\n\n                            // Apply thrust based on input\n                            if (inputState.left) {\n                                // Thrust to the left (opposite of right direction)\n                                dv[0] += rnx * dvScale;\n                                dv[2] += rnz * dvScale;\n                            }\n                            if (inputState.right) {\n                                // Thrust to the right\n                                dv[0] -= rnx * dvScale;\n                                dv[2] -= rnz * dvScale;\n                            }\n                            if (inputState.up) {\n                                // Thrust forward (in velocity direction)\n                                dv[0] += fx * dvScale;\n                                dv[2] += fz * dvScale;\n                            }\n                            if (inputState.down) {\n                                // Thrust backward (brake)\n                                dv[0] -= fx * dvScale;\n                                dv[2] -= fz * dvScale;\n                            }\n                        } else {\n                            // Fallback to world-axis control when stationary\n                            if (inputState.left) dv[0] -= dvScale;\n                            if (inputState.right) dv[0] += dvScale;\n                            if (inputState.up) dv[2] -= dvScale;\n                            if (inputState.down) dv[2] += dvScale;\n                        }\n                    }\n\n                    if (dv[0] !== 0 || dv[1] !== 0 || dv[2] !== 0) {\n                        // Calculate fuel consumption based on delta-v magnitude\n                        const dvMagnitude = Math.sqrt(dv[0] * dv[0] + dv[1] * dv[1] + dv[2] * dv[2]);\n                        const fuelConsumed = dvMagnitude * PHYSICS_SCALE.FUEL_CONSUMPTION_RATE;\n\n                        // Check if enough fuel available\n                        if (state.fuel > 0) {\n                            // Consume fuel\n                            state.fuel = Math.max(0, state.fuel - fuelConsumed);\n\n                            // Apply thrust\n                            try {\n                                // call exported helper bound in threeSetup\n                                (window as any).__applyDeltaVToProbe ? (window as any).__applyDeltaVToProbe(dv) : (initThreeJS as any).applyDeltaVToProbe?.(dv);\n                            } catch (e) {\n                                try { (initThreeJS as any).applyDeltaVToProbe?.(dv); } catch (e) {}\n                            }\n                        }\n                        // If fuel depleted, thrust is not applied (status will be set in stepSimulation)\n                    }\n                    stepSimulation(fixedTimeStep);\n                } catch (e) {\n                    // swallow physics errors to keep render loop alive\n                    console.error('physics step error', e);\n                }\n                accumulator -= fixedTimeStep;\n            }\n\n            // synchronize visual probe mesh with simulated state\n            try {\n                if (probe && state.position) probe.position.copy(state.position);\n            } catch (e) {\n                // ignore copy errors in unusual cases\n            }\n\n            // update camera position based on view mode\n            try {\n                if (cameraViewRef.current === 'top') {\n                    // Top view: camera above the sun\n                    camera.position.set(0, 1500, 0);\n                    camera.lookAt(0, 0, 0);\n                    controls.enabled = false;\n                } else if (cameraViewRef.current === 'probe') {\n                    // Probe follow view: camera behind and above the probe\n                    if (probe && state.position) {\n                        const probePos = state.position;\n                        const vel = state.velocity;\n                        const speed = vel ? vel.length() : 0;\n\n                        if (speed > 0.1) {\n                            // Position camera behind the probe based on velocity direction\n                            const velNorm = vel.clone().normalize();\n                            const camOffset = velNorm.multiplyScalar(-150); // 150 units behind\n                            const camPos = probePos.clone().add(camOffset);\n                            camPos.y += 80; // 80 units above\n\n                            camera.position.copy(camPos);\n                            camera.lookAt(probePos.x, probePos.y, probePos.z);\n                        } else {\n                            // If probe is stationary, use fixed offset\n                            camera.position.set(probePos.x, probePos.y + 80, probePos.z + 150);\n                            camera.lookAt(probePos.x, probePos.y, probePos.z);\n                        }\n                    }\n                    controls.enabled = false;\n                } else {\n                    // Free view: enable orbit controls\n                    controls.enabled = true;\n                    controls.update();\n                }\n            } catch (e) {\n                // ignore camera update errors\n            }\n\n            // add trail point periodically (every 100ms)\n            if (addTrailPoint) {\n                const nowMsPoint = performance.now();\n                if (!trailRef.current) trailRef.current = { lastMs: nowMsPoint };\n                if (nowMsPoint - trailRef.current.lastMs > 100) {\n                    try {\n                        addTrailPoint(state.position);\n                    } catch (e) {\n                        // ignore\n                    }\n                    trailRef.current.lastMs = nowMsPoint;\n                }\n            }\n\n                // update HUD if setters provided (throttled)\n                if (hudSetters) {\n                    const nowMs = performance.now();\n                    const lastMs = (hudUpdateRef.current && hudUpdateRef.current.lastMs) || 0;\n                    const lastVals = (hudUpdateRef.current && hudUpdateRef.current.lastVals) || { velocity: -1, distance: -1, fuel: -1, slingshots: -1, status: '' };\n\n                    const speed = state.velocity ? state.velocity.length() : 0;\n                    const speedKmPerSec = speed * PHYSICS_SCALE.VELOCITY_TO_KM_PER_SEC;\n                    const shouldUpdateTime = nowMs - lastMs > 200; // 200ms throttle\n                    const largeChange = Math.abs(speedKmPerSec - lastVals.velocity) > 0.7 || Math.abs(state.distance - lastVals.distance) > 0.1 || Math.abs(state.fuel - lastVals.fuel) > 1 || state.slingshots !== lastVals.slingshots || state.status !== lastVals.status;\n\n                    if (shouldUpdateTime || largeChange) {\n                        hudSetters.setVelocity(speedKmPerSec);\n                        hudSetters.setDistance(state.distance);\n                        hudSetters.setFuel(state.fuel);\n                        hudSetters.setSlingshots(state.slingshots);\n                        hudSetters.setStatus(state.status);\n\n                        hudUpdateRef.current = { lastMs: nowMs, lastVals: { velocity: speedKmPerSec, distance: state.distance, fuel: state.fuel, slingshots: state.slingshots, status: state.status } };\n                    }\n                }\n\n            renderer.render(scene, camera);\n            rafRef.current = requestAnimationFrame(animate);\n        };\n\n        rafRef.current = requestAnimationFrame(animate);\n\n        return () => {\n            if (rafRef.current) cancelAnimationFrame(rafRef.current);\n            dispose();\n            window.removeEventListener('keydown', onKeyDown);\n            window.removeEventListener('keyup', onKeyUp);\n        };\n    }, [hudSetters, probeSpeedMult, gravityG, starMass]);\n\n    return <canvas ref={canvasRef} style={{ display: 'block', width: '100vw', height: '100vh' }} />;\n};\n\nexport default GameCanvas;"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1272, "column": 0}, "map": {"version":3,"sources":["file:///D:/my_projects/space-probe-game-next/space-probe-game-next/src/components/HUD.tsx"],"sourcesContent":["import React from 'react';\n\ninterface HUDProps {\n    status?: string;\n    velocity?: number;\n    distance?: number;\n    fuel?: number;\n    slingshots?: number;\n}\n\nconst HUD: React.FC<HUDProps> = ({\n    status = 'Idle',\n    velocity = 0,\n    distance = 0,\n    fuel = 100,\n    slingshots = 0,\n}) => {\n    return (\n        <div id=\"ui\">\n            <h2>探査機データ</h2>\n            <p><span className=\"stat-label\">状態:</span><span className=\"stat-value\">{status}</span></p>\n            <p><span className=\"stat-label\">速度:</span><span className=\"stat-value\">{velocity.toFixed(1)}</span> km/s</p>\n            <p><span className=\"stat-label\">距離:</span><span className=\"stat-value\">{distance.toFixed(2)}</span> AU</p>\n            <p><span className=\"stat-label\">燃料:</span><span className=\"stat-value\">{fuel.toFixed(1)}</span>%</p>\n            <p><span className=\"stat-label\">スイングバイ:</span><span className=\"stat-value\">{slingshots}</span> 回</p>\n        </div>\n    );\n};\n\nexport default HUD;"],"names":[],"mappings":";;;;;;AAUA,MAAM,MAA0B,CAAC,EAC7B,SAAS,MAAM,EACf,WAAW,CAAC,EACZ,WAAW,CAAC,EACZ,OAAO,GAAG,EACV,aAAa,CAAC,EACjB;IACG,qBACI,6LAAC;QAAI,IAAG;;0BACJ,6LAAC;0BAAG;;;;;;0BACJ,6LAAC;;kCAAE,6LAAC;wBAAK,WAAU;kCAAa;;;;;;kCAAU,6LAAC;wBAAK,WAAU;kCAAc;;;;;;;;;;;;0BACxE,6LAAC;;kCAAE,6LAAC;wBAAK,WAAU;kCAAa;;;;;;kCAAU,6LAAC;wBAAK,WAAU;kCAAc,SAAS,OAAO,CAAC;;;;;;oBAAU;;;;;;;0BACnG,6LAAC;;kCAAE,6LAAC;wBAAK,WAAU;kCAAa;;;;;;kCAAU,6LAAC;wBAAK,WAAU;kCAAc,SAAS,OAAO,CAAC;;;;;;oBAAU;;;;;;;0BACnG,6LAAC;;kCAAE,6LAAC;wBAAK,WAAU;kCAAa;;;;;;kCAAU,6LAAC;wBAAK,WAAU;kCAAc,KAAK,OAAO,CAAC;;;;;;oBAAU;;;;;;;0BAC/F,6LAAC;;kCAAE,6LAAC;wBAAK,WAAU;kCAAa;;;;;;kCAAc,6LAAC;wBAAK,WAAU;kCAAc;;;;;;oBAAkB;;;;;;;;;;;;;AAG1G;KAjBM;uCAmBS","debugId":null}},
    {"offset": {"line": 1431, "column": 0}, "map": {"version":3,"sources":["file:///D:/my_projects/space-probe-game-next/space-probe-game-next/src/components/Controls.tsx"],"sourcesContent":["import React from 'react';\n\nexport type CameraView = 'free' | 'top' | 'probe';\n\ntype Props = {\n    probeSpeedMult: number;\n    setProbeSpeedMult: (v: number) => void;\n    gravityG: number;\n    setGravityG: (v: number) => void;\n    starMass: number;\n    setStarMass: (v: number) => void;\n    cameraView: CameraView;\n    setCameraView: (v: CameraView) => void;\n};\n\nconst Controls: React.FC<Props> = ({ probeSpeedMult, setProbeSpeedMult, gravityG, setGravityG, starMass, setStarMass, cameraView, setCameraView }) => {\n    return (\n        <div id=\"controls\">\n            <h3>操作方法</h3>\n            <p>← : 進行方向の左に推進</p>\n            <p>→ : 進行方向の右に推進</p>\n            <p>↑ : 進行方向に加速</p>\n            <p>↓ : 進行方向に減速（ブレーキ）</p>\n            <p>R : リスタート</p>\n            <p style={{ fontSize: '0.85em', marginTop: '8px', color: '#888' }}>\n                ※矢印キーは常に探査機の速度方向を基準にします\n            </p>\n\n            <hr />\n            <div>\n                <label>カメラ視点:</label>\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '8px' }}>\n                    <button\n                        onClick={() => setCameraView('free')}\n                        style={{\n                            padding: '8px 12px',\n                            backgroundColor: cameraView === 'free' ? '#4CAF50' : '#555',\n                            color: 'white',\n                            border: 'none',\n                            borderRadius: '4px',\n                            cursor: 'pointer',\n                            fontSize: '14px'\n                        }}\n                    >\n                        自由視点（マウス操作）\n                    </button>\n                    <button\n                        onClick={() => setCameraView('top')}\n                        style={{\n                            padding: '8px 12px',\n                            backgroundColor: cameraView === 'top' ? '#4CAF50' : '#555',\n                            color: 'white',\n                            border: 'none',\n                            borderRadius: '4px',\n                            cursor: 'pointer',\n                            fontSize: '14px'\n                        }}\n                    >\n                        真上視点（太陽中心）\n                    </button>\n                    <button\n                        onClick={() => setCameraView('probe')}\n                        style={{\n                            padding: '8px 12px',\n                            backgroundColor: cameraView === 'probe' ? '#4CAF50' : '#555',\n                            color: 'white',\n                            border: 'none',\n                            borderRadius: '4px',\n                            cursor: 'pointer',\n                            fontSize: '14px'\n                        }}\n                    >\n                        探査機追従視点\n                    </button>\n                </div>\n            </div>\n\n            <hr />\n            <div>\n                <label>Probe speed multiplier: {probeSpeedMult.toFixed(2)}</label>\n                <input type=\"range\" min=\"0.95\" max=\"1.50\" step=\"0.01\" value={probeSpeedMult} onChange={(e) => setProbeSpeedMult(Number(e.target.value))} />\n            </div>\n            <div>\n                <label>Gravity G: {gravityG.toFixed(3)}</label>\n                <input type=\"range\" min=\"0.01\" max=\"1.0\" step=\"0.01\" value={gravityG} onChange={(e) => setGravityG(Number(e.target.value))} />\n            </div>\n            <div>\n                <label>Star mass: {Math.round(starMass).toLocaleString()}</label>\n                <input type=\"range\" min=\"50000\" max=\"500000\" step=\"5000\" value={starMass} onChange={(e) => setStarMass(Number(e.target.value))} />\n            </div>\n        </div>\n    );\n};\n\nexport default Controls;"],"names":[],"mappings":";;;;;;AAeA,MAAM,WAA4B,CAAC,EAAE,cAAc,EAAE,iBAAiB,EAAE,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,aAAa,EAAE;IAC7I,qBACI,6LAAC;QAAI,IAAG;;0BACJ,6LAAC;0BAAG;;;;;;0BACJ,6LAAC;0BAAE;;;;;;0BACH,6LAAC;0BAAE;;;;;;0BACH,6LAAC;0BAAE;;;;;;0BACH,6LAAC;0BAAE;;;;;;0BACH,6LAAC;0BAAE;;;;;;0BACH,6LAAC;gBAAE,OAAO;oBAAE,UAAU;oBAAU,WAAW;oBAAO,OAAO;gBAAO;0BAAG;;;;;;0BAInE,6LAAC;;;;;0BACD,6LAAC;;kCACG,6LAAC;kCAAM;;;;;;kCACP,6LAAC;wBAAI,OAAO;4BAAE,SAAS;4BAAQ,eAAe;4BAAU,KAAK;4BAAO,WAAW;wBAAM;;0CACjF,6LAAC;gCACG,SAAS,IAAM,cAAc;gCAC7B,OAAO;oCACH,SAAS;oCACT,iBAAiB,eAAe,SAAS,YAAY;oCACrD,OAAO;oCACP,QAAQ;oCACR,cAAc;oCACd,QAAQ;oCACR,UAAU;gCACd;0CACH;;;;;;0CAGD,6LAAC;gCACG,SAAS,IAAM,cAAc;gCAC7B,OAAO;oCACH,SAAS;oCACT,iBAAiB,eAAe,QAAQ,YAAY;oCACpD,OAAO;oCACP,QAAQ;oCACR,cAAc;oCACd,QAAQ;oCACR,UAAU;gCACd;0CACH;;;;;;0CAGD,6LAAC;gCACG,SAAS,IAAM,cAAc;gCAC7B,OAAO;oCACH,SAAS;oCACT,iBAAiB,eAAe,UAAU,YAAY;oCACtD,OAAO;oCACP,QAAQ;oCACR,cAAc;oCACd,QAAQ;oCACR,UAAU;gCACd;0CACH;;;;;;;;;;;;;;;;;;0BAMT,6LAAC;;;;;0BACD,6LAAC;;kCACG,6LAAC;;4BAAM;4BAAyB,eAAe,OAAO,CAAC;;;;;;;kCACvD,6LAAC;wBAAM,MAAK;wBAAQ,KAAI;wBAAO,KAAI;wBAAO,MAAK;wBAAO,OAAO;wBAAgB,UAAU,CAAC,IAAM,kBAAkB,OAAO,EAAE,MAAM,CAAC,KAAK;;;;;;;;;;;;0BAEzI,6LAAC;;kCACG,6LAAC;;4BAAM;4BAAY,SAAS,OAAO,CAAC;;;;;;;kCACpC,6LAAC;wBAAM,MAAK;wBAAQ,KAAI;wBAAO,KAAI;wBAAM,MAAK;wBAAO,OAAO;wBAAU,UAAU,CAAC,IAAM,YAAY,OAAO,EAAE,MAAM,CAAC,KAAK;;;;;;;;;;;;0BAE5H,6LAAC;;kCACG,6LAAC;;4BAAM;4BAAY,KAAK,KAAK,CAAC,UAAU,cAAc;;;;;;;kCACtD,6LAAC;wBAAM,MAAK;wBAAQ,KAAI;wBAAQ,KAAI;wBAAS,MAAK;wBAAO,OAAO;wBAAU,UAAU,CAAC,IAAM,YAAY,OAAO,EAAE,MAAM,CAAC,KAAK;;;;;;;;;;;;;;;;;;AAI5I;KA7EM;uCA+ES","debugId":null}},
    {"offset": {"line": 1693, "column": 0}, "map": {"version":3,"sources":["file:///D:/my_projects/space-probe-game-next/space-probe-game-next/src/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { useState, useCallback } from 'react';\nimport GameCanvas from '../components/GameCanvas';\nimport HUD from '../components/HUD';\nimport Controls, { CameraView } from '../components/Controls';\nimport { PHYSICS_SCALE } from '../lib/threeSetup';\n\nconst Page = () => {\n    const [status, setStatus] = useState<string>('Idle');\n    const [velocity, setVelocity] = useState<number>(0);\n    const [distance, setDistance] = useState<number>(0);\n    const [fuel, setFuel] = useState<number>(100);\n    const [slingshots, setSlingshots] = useState<number>(0);\n\n    // simulation tuning parameters (editable via Controls)\n    const [probeSpeedMult, setProbeSpeedMult] = useState<number>(1.05);\n    const [gravityG, setGravityG] = useState<number>(PHYSICS_SCALE.G);\n    const [starMass, setStarMass] = useState<number>(PHYSICS_SCALE.SUN_MASS);\n    const [cameraView, setCameraView] = useState<CameraView>('free');\n\n    // stable setters object to pass down (memoized so reference is stable)\n    const hudSetters = React.useMemo(\n        () => ({ setStatus, setVelocity, setDistance, setFuel, setSlingshots }),\n        [setStatus, setVelocity, setDistance, setFuel, setSlingshots]\n    );\n\n    return (\n        <div>\n            <GameCanvas hudSetters={hudSetters} probeSpeedMult={probeSpeedMult} gravityG={gravityG} starMass={starMass} cameraView={cameraView} />\n            <HUD status={status} velocity={velocity} distance={distance} fuel={fuel} slingshots={slingshots} />\n            <Controls probeSpeedMult={probeSpeedMult} setProbeSpeedMult={setProbeSpeedMult} gravityG={gravityG} setGravityG={setGravityG} starMass={starMass} setStarMass={setStarMass} cameraView={cameraView} setCameraView={setCameraView} />\n        </div>\n    );\n};\n\nexport default Page;"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;;;AANA;;;;;;AAQA,MAAM,OAAO;;IACT,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAS;IAC7C,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAS;IACjD,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAS;IACjD,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAS;IACzC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,yKAAQ,EAAS;IAErD,uDAAuD;IACvD,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAS;IAC7D,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAS,4IAAa,CAAC,CAAC;IAChE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAS,4IAAa,CAAC,QAAQ;IACvE,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,yKAAQ,EAAa;IAEzD,uEAAuE;IACvE,MAAM,aAAa,wKAAK,CAAC,OAAO;oCAC5B,IAAM,CAAC;gBAAE;gBAAW;gBAAa;gBAAa;gBAAS;YAAc,CAAC;mCACtE;QAAC;QAAW;QAAa;QAAa;QAAS;KAAc;IAGjE,qBACI,6LAAC;;0BACG,6LAAC,8IAAU;gBAAC,YAAY;gBAAY,gBAAgB;gBAAgB,UAAU;gBAAU,UAAU;gBAAU,YAAY;;;;;;0BACxH,6LAAC,uIAAG;gBAAC,QAAQ;gBAAQ,UAAU;gBAAU,UAAU;gBAAU,MAAM;gBAAM,YAAY;;;;;;0BACrF,6LAAC,4IAAQ;gBAAC,gBAAgB;gBAAgB,mBAAmB;gBAAmB,UAAU;gBAAU,aAAa;gBAAa,UAAU;gBAAU,aAAa;gBAAa,YAAY;gBAAY,eAAe;;;;;;;;;;;;AAG/N;GA1BM;KAAA;uCA4BS","debugId":null}}]
}